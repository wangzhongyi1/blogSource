# javascript 性能优化(2)

## 性能优化的根本目的

要思考的是用户使用网站的体验如何，而不是我们可以节省多少字节，只有准确感知用户的感受，我们才有必要谈毫秒、字节和请求量等问题

## 针对优化注意事项

- 防止过早优化：没必要在刚开始阶段就对一个细节进行放大型的优化，因为这样的成本很高，除了代码可读性方面的东西，甚至还可能会引入更多的bug，所以针对这个问题，我们可以在上线和运营的时候进行监控，当快暴露问题的时候，进行整体优化
- 本末倒置的关注：网店内容是最重要的，应该查看页面的每个部分，看是否满足网站页面的主要目的，暂时不需要将额外的注意力全部放到一些不关乎本地的东西上。

## 对于性能的分析

- 使用浏览器的性能分析工具，得到性能分析图标，最著名的就是反向火焰图表，针对浏览器的加载和渲染一目了然
- 投入使用之前缺乏压力测试和性能测试

## 性能优化（从用户输入网站到客户端呈现，一步一步优化）

1. 输入网址 --- 告诉浏览器你要去哪里

2. 浏览器查找DNS --- 网络世界是IP地址的世界，DNS就是IP地址的别名。从本地DNS到最顶级DNS一步一步的往上爬，直到命中需要访问的IP地址
  - DNS预解析 --- 使用CDN缓存，加快解析CDN寻找到目标地址（dns-prefetch）
  
3. 客户端和服务器建立连接 --- 建立TCP安全通道，3次握手
  - CDN加速 --- 使用内容分发网络，让用户更快的获取到所要的内容
  - 启用压缩 --- 在http协议中，使用类似Gzip压缩的方案
  - 使用HTTP2.0协议 --- http2.0 针对 1.0 优化了很多东西，包括多路复用，头压缩等等，使得传输更快

4. 浏览器发送http请求 --- 默认长连接（复用一个tcp通道，短连接：每次连接完就销毁）
  - 减少http请求 -- 每个请求从创建到销毁都会消耗很多资源和时间，减少请求就可以相对来说更快展示内容
    + 合并压缩css文件和js文件
    + 针对图片，可将图片进行合并然后下载，通过 css Sprites 切割展示（控制大小，太大反而适得其反）
  - 使用http缓存 -- 换成原则：越多越好，越久越好。让客户端发送更少请求，直接从本地获取，加快性能
  - 减少cookie请求 -- 针对非必要数据（静态资源）请求，进行跨域隔离，减少传输内容大小
  - 预加载请求 -- 针对一些业务中场景可预加载的内容，提前加载，在之后的用户操作中更少的请求，更快的响应
  - 选择get和post -- 在http定义的时候，get本质上就是获取数据，post是发送数据。get可以在一个TCP报文完成请求，但是post要先发header，再发送数据
  - 缓存方案选型 -- 递进式缓存更新（防止一次性丢失大量缓存，导致负载骤多）

5. 服务器响应请求 -- tomcat、IIS等服务器通过本地映射文件关系找到地址或通过数据库查询数据，处理完后返回浏览器
  - 后端框架选项 -- 更快的响应，前端更快的操作
  - 数据库选项和优化 -- 更快的响应，前端更快的操作

6. 浏览器接受响应 -- 浏览器根据报文头里面的数据进行不同的响应处理
  - 解耦第三方依赖 -- 越多的第三方的不确定因素，会导致web的不稳定性和不确定性
  - 避免404资源 -- 请求资源不到浪费了从请求到接受的所有资源

7. 浏览器渲染顺序
  - HTML解析，开始构建dom树
  - 外部脚本和样式表加载完毕
    + 尽快加载css，首先将CSSOM对象渲染出来，然后进行页面渲染，否则导致页面闪屏，用户体验差
    + css选择器是从右往左解析的，所以类似`#test a {color: #333}`，css解析器会查找所有 a标签 的祖先节点，所以效率不是那么高
    + 在css的媒体查询中，最好不要直接和任何css规则相关。最好写到link标签中，告诉浏览器，只有在这个媒介下，加载指定这个css
  - 脚本在文档内解析并执行
    + 按需加载脚本，例如现在的 webpack 就可以打包和按需加载 js脚本
    + 将脚本标记为异步，不阻塞页面渲染，获得最佳启动，保证无关主要的脚本不会阻塞页面
    + 慎重选型框架和类库，避免只是用类库和框架的一个功能或函数，而引入整个文件
  - HTML DOM 完全构建起来
    + DOM 的多个读操作（或多个写操作），应该放在一起。原则：统一读、统一写
  - 图片和外部内容加载
    + 对多媒体内容进行适当优化，包括恰当使用文件格式，文件处理，渐进式渲染等
    + 避免空的src，空的src仍然会发送请求到服务器
    + 避免在 html 内容中缩放图片，如果你需要使用小图，则直接使用小图
  - 网页完成加载
    + 服务端渲染，特别针对首屏加载很重要的网址，可以考虑这个方案。后端渲染结束，前端接管展示

### 以下为代码层面的优化

1. 针对首屏展示优化
  - 图片懒加载，针对展示只加载第一屏，等用户进行滚动的时候再进行加载。
  - 浏览器本地缓存模块，可以通过按模块去划分，将页面的模块缓存到localStorage中，每次请求核对模块版本号，丢失或者版本不一致重新请求，否则直接从本地拿

2. javascript优化
  - 减少对dom节点的查询，因为每次都会重新去索引这个集合或者元素。或者查询一次缓存起来，以待接下来使用
  - 进行js操作DOM的时候，考虑清楚页面的回流和重绘，因为这些操作相对来说十分损耗性能
  - 避免使用 eval 和 Function 构造，因为解析器会将这些内容先转换成可执行代码，然后再进行接下来的操作
  - 减少作用域链的查询，如果一个闭包函数使用到全局作用域的数据，那么每次局部作用域都会一层一层爬到顶层作用域获取数据
  - 数据访问，对非引用类型数据访问和局部变量的访问是最快的。所以如果对引用类型的成员访问超过一次，则缓存
  - 将前端可能会使用的一些算法函数写的更优，在时间和空间复杂度上寻找一个最优方案
  - 去除重复加载同一模块脚本
  - 智能事件处理，比如在一个div下有10个按钮，可以在冒泡过程中捕获这个事件源，然后注册

3. css优化
  - 删除无用规则
  - 内联关键css
  - 避免@import和Base64
  - 启用高性价比属性（如：opacity vs rgba()）
  - 避免重复性工作
  - 不要一条一条改变样式，而要通过改变css，或者cssText属性，一次性改变样式
  - 可将元素设置为 `display: noe`，然后N次操作，最后恢复显示
  - position属性为absolute或fixed的元素，回流的开销会比较小，因为不用考虑它对其他元素的影响

4. 图片优化（网络请求中80%都是静态资源的请求）
  - 图片正确格式的选择
  - 图片尺寸的选择，在低分辨率等情况下考虑降级处理（考虑兼容式图片）
  - 使用正确的工具进行优化（有损压缩，无损压缩）
  - 能用css处理的，优先考虑css实现（阴影、滤镜等）
  - 正确使用data url，比如说多地使用，不建议data url，可考虑缓存
  - 考虑图片懒加载和元素可见性加载方案
  - 图片的预加载，在正确的合理的设计节点进行图片的预加载

## 总结

所有性能优化总结为三个层面优化：物理层面，设计层面，代码层面

注：设计层优化最主要的核心：衡量如何花费最少代价实现页面功能